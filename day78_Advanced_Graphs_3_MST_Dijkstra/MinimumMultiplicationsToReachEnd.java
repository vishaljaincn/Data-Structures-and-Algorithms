package day78_Advanced_Graphs_3_MST_Dijkstra;

import java.util.LinkedList;
import java.util.Queue;

/*
Given start, end and an array arr of n numbers. At each step, start is multiplied with any number in the array and then
mod operation with 100000 is done to get the new start.

Your task is to find the minimum steps in which end can be achieved starting from start. If it is not possible to reach
end, then return -1.

Example 1:
Input:
arr[] = {2, 5, 7}
start = 3, end = 30
Output:
2
Explanation:
Step 1: 3*2 = 6 % 100000 = 6
Step 2: 6*5 = 30 % 100000 = 30

Example 2:
Input:
arr[] = {3, 4, 65}
start = 7, end = 66175
Output:
4
Explanation:
Step 1: 7*3 = 21 % 100000 = 21
Step 2: 21*3 = 63 % 100000 = 63
Step 3: 63*65 = 4095 % 100000 = 4095
Step 4: 4095*65 = 266175 % 100000 = 66175
Your Task:
You don't need to print or input anything. Complete the function minimumMultiplications() which takes an integer array
arr, an integer start and an integer end as the input parameters and returns an integer, denoting the minumum steps to
reach in which end can be achieved starting from start.
*/
/*
Time Complexity : O(100000 * N)
Where ‘100000’ are the total possible numbers generated by multiplication (hypothetical) and N = size of the array with
numbers of which each node could be multiplied.

Space Complexity :  O(100000 * N)
Where ‘100000’ are the total possible numbers generated by multiplication (hypothetical) and N = size of the array with
numbers of which each node could be multiplied. 100000 * N is the max possible queue size. The space complexity of the
dist array is constant.
 */

class Paire {
    int first, second;

    // Constructor for the Pair class
    Paire(int first, int second) {
        this.first = first;
        this.second = second;
    }
}

public class MinimumMultiplicationsToReachEnd {
    int minimumMultiplications(int[] arr, int start, int end) {
        Queue<Paire> q = new LinkedList<>();
        q.add(new Paire(start, 0));
        int[] dist = new int[100000];

        // Initializing the dist array with a large value
        for (int i = 0; i < 100000; i++) dist[i] = (int) (1e9);
        dist[start] = 0;

        int mod = 100000;
        int n = arr.length;

        // BFS to find the minimum steps to reach 'end'
        while (!q.isEmpty()) {
            int node = q.peek().first;
            int steps = q.peek().second;
            q.remove();

            // Iterate through each number in the array
            for (int i = 0; i < n; i++) {
                int num = (arr[i] * node) % mod;

                // If a shorter path is found, update the distance and enqueue the new node
                if (steps + 1 < dist[num]) {
                    dist[num] = steps + 1;

                    // If the target 'end' is reached, return the minimum steps
                    if (num == end) return steps + 1;

                    q.add(new Paire(num, steps + 1));
                }
            }
        }

        // If 'end' cannot be reached, return -1
        return -1;
    }
}
